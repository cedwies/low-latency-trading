#pragma once

#include "trading/core/order_book.h"
#include <chrono>
#include <functional>
#include <memory>
#include <string>
#include <unordered_map>
#include <vector>

namespace trading {

// Forward declarations
class MarketDataHandler;

// Signal types generated by strategies
enum class SignalType : uint8_t {
    NONE = 0,
    BUY = 1,
    SELL = 2
};

// Signal structure
struct Signal {
    SignalType type;
    std::string symbol;
    Price price;
    Quantity quantity;
    double confidence;
    Timestamp timestamp;
    
    // Constructor
    Signal(SignalType t, std::string_view sym, Price p, Quantity q, double conf, Timestamp ts)
        : type(t), symbol(sym), price(p), quantity(q), confidence(conf), timestamp(ts) {}
    
    // Default constructor
    Signal() : type(SignalType::NONE), price(0), quantity(0), confidence(0.0), timestamp(0) {}
};

// Strategy interface
class Strategy {
public:
    virtual ~Strategy() = default;
    
    // Initialize the strategy
    virtual void initialize() = 0;
    
    // Process an order book update and generate signals
    virtual std::vector<Signal> process_update(const std::shared_ptr<OrderBook>& order_book) = 0;
    
    // Get strategy name
    virtual std::string name() const = 0;
};

// Statistical arbitrage strategy implementation
class StatArbitrageStrategy : public Strategy {
public:
    // Constructor
    StatArbitrageStrategy(std::vector<std::string> symbols, 
                         double z_score_threshold = 2.0, 
                         size_t window_size = 100);
    
    // Initialize the strategy
    void initialize() override;
    
    // Process an order book update and generate signals
    std::vector<Signal> process_update(const std::shared_ptr<OrderBook>& order_book) override;
    
    // Get strategy name
    std::string name() const override;
    
private:
    // Symbols to monitor
    std::vector<std::string> symbols_;
    
    // Z-score threshold for generating signals
    double z_score_threshold_;
    
    // Window size for calculation
    size_t window_size_;
    
    // Historical mid prices for each symbol
    std::unordered_map<std::string, std::vector<double>> price_history_;
    
    // Calculate Z-score for a pair of symbols
    double calculate_z_score(const std::string& symbol1, const std::string& symbol2);
};

// Strategy engine class to manage strategies and generate signals
class StrategyEngine {
public:
    // Constructor
    StrategyEngine(std::shared_ptr<MarketDataHandler> market_data);
    
    // Start the strategy engine
    void start();
    
    // Stop the strategy engine
    void stop();
    
    // Register a strategy
    void register_strategy(std::shared_ptr<Strategy> strategy);
    
    // Set signal callback
    void set_signal_callback(std::function<void(const Signal&)> callback);
    
    // Process order book updates
    void process_order_book(const std::shared_ptr<OrderBook>& order_book);
    
private:
    // Market data handler
    std::shared_ptr<MarketDataHandler> market_data_;
    
    // Registered strategies
    std::vector<std::shared_ptr<Strategy>> strategies_;
    
    // Signal callback
    std::function<void(const Signal&)> signal_callback_;
    
    // Running flag
    bool running_;
};

} // namespace trading